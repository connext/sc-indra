import { singleton, inject } from "tsyringe";
import { WalletInterface } from "@statechannels/server-wallet";
import {
  JoinChannelParams,
  UpdateChannelParams,
  CloseChannelParams,
  GetStateParams as GetChannelParams,
  CreateChannelParams,
  ChallengeChannelParams,
  PushMessageParams,
  JsonRpcErrorResponse,
  StateChannelsRequest,
  StateChannelsError,
  StateChannelsResponse,
  isJsonRpcErrorResponse,
  isJsonRpcResponse,
  JsonRpcRequest,
} from "@statechannels/client-api-schema";
import { INJECTION_TOKEN } from "../constants";
import { safeJsonStringify } from "../utils";
import {
  SingleChannelResult,
  MultipleChannelResult,
  GetParticipantResult,
  GetVersionResult,
  DefundChannelParams,
  GetParticipantParams,
  StateChannelsMethod,
  GetChannelsParams,
  StateChannelsParameters,
  StateChannelsResults,
  IRpcService,
} from "../types";
import { JsonRpcResponse } from "@connext/types";
import { Message } from "@statechannels/wallet-core";

/**
 * This class handles communication between the channel wallet and the
 * application logic. It accepts javascript objects generated by the
 * application layer, and dispatches them to the channel wallet through
 * rpc requests.
 *
 * The channel wallet will return a request or an error, which will be
 * returned or thrown, respectively.
 */
@singleton()
export class WalletRpcService implements IRpcService {
  constructor(
    @inject(INJECTION_TOKEN.CHANNEL_WALLET)
    private readonly channelWallet: WalletInterface,
  ) {}
  dispatch(
    request: JsonRpcRequest<string, object>,
  ): Promise<JsonRpcResponse | JsonRpcErrorResponse<any>> {
    throw new Error("Method not implemented.");
  }

  // TODO: switch to RPC interface
  public async createChannel(params: CreateChannelParams): SingleChannelResult {
    // return this.sendRpcRequest("CreateChannel", params);
    return this.channelWallet.createChannel(params);
  }
  public async joinChannel(params: JoinChannelParams): SingleChannelResult {
    return this.sendRpcRequest("JoinChannel", params);
  }
  public async updateChannel(params: UpdateChannelParams): SingleChannelResult {
    return this.sendRpcRequest("UpdateChannel", params);
  }
  public async closeChannel(params: CloseChannelParams): SingleChannelResult {
    return this.sendRpcRequest("CloseChannel", params);
  }
  public async defundChannel(params: DefundChannelParams): SingleChannelResult {
    return this.sendRpcRequest("DefundChannel", params);
  }
  public async challengeChannel(params: ChallengeChannelParams): SingleChannelResult {
    return this.sendRpcRequest("ChallengeChannel", params);
  }
  public async getChannels(params: GetChannelsParams): MultipleChannelResult {
    return this.sendRpcRequest("GetChannels", params);
  }
  public async getChannel(params: GetChannelParams): SingleChannelResult {
    return this.sendRpcRequest("GetChannel", params);
  }
  public async getParticipant(params: GetParticipantParams): Promise<GetParticipantResult> {
    return this.sendRpcRequest("GetParticipant", params);
  }
  public async getVersion(): Promise<GetVersionResult> {
    return this.sendRpcRequest("GetVersion", {});
  }
  public async pushMessage(params: PushMessageParams): MultipleChannelResult {
    // return this.sendRpcRequest("PushMessage", params);
    return this.channelWallet.pushMessage(params.data as Message);
  }

  private async sendRpcRequest<T extends StateChannelsMethod>(
    method: T,
    params: StateChannelsParameters[T],
  ): Promise<StateChannelsResults[T]> {
    // Generate + dispatch request
    const request: StateChannelsRequest = {
      id: Date.now(),
      jsonrpc: "2.0",
      method: method as any,
      params,
    };
    // const response = await this.channelWallet.dispatch(request);
    const response = {};
    if (!isJsonRpcErrorResponse(response)) {
      const error = (response as JsonRpcErrorResponse).error as StateChannelsError;
      // FIXME: add more logging for specialized error context from sc
      // error type
      throw new Error(error.message);
    }

    if (isJsonRpcResponse(response)) {
      return (response as StateChannelsResponse).result as StateChannelsResults[T];
    }

    throw new Error(
      `Unable to determine if this is json rpc result or error: ${safeJsonStringify(response)}`,
    );
  }
}
